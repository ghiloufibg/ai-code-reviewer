package com.ghiloufi.aicode.client.github;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import org.apache.hc.client5.http.classic.methods.HttpGet;
import org.apache.hc.client5.http.classic.methods.HttpPost;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;
import org.apache.hc.core5.http.HttpEntity;
import org.apache.hc.core5.http.HttpStatus;
import org.apache.hc.core5.http.io.entity.StringEntity;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.EmptySource;
import org.junit.jupiter.params.provider.NullSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

/**
 * Tests unitaires pour {@link GithubClient}.
 *
 * <p>Cette classe teste tous les sc√©narios du client GitHub en mockant les appels HTTP pour √©viter
 * les d√©pendances externes.
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("GithubClient")
class GithubClientTest {

  private static final String TEST_REPO = "owner/repo";
  private static final String TEST_TOKEN = "ghp_testtoken123";
  private static final int TEST_PR_NUMBER = 42;
  private static final String TEST_DIFF_CONTENT =
      "diff --git a/file.txt b/file.txt\n"
          + "--- a/file.txt\n"
          + "+++ b/file.txt\n"
          + "@@ -1,3 +1,3 @@\n"
          + "-old line\n"
          + "+new line\n";
  private static final String TEST_COMMENT = "This is a test comment";

  @Mock private CloseableHttpClient mockHttpClient;

  @Mock private CloseableHttpResponse mockResponse;

  @Mock private HttpEntity mockEntity;

  private GithubClient githubClient;
  private GithubClient githubClientWithoutToken;

  @BeforeEach
  void setUp() {
    //    reset(mockHttpClient, mockResponse, mockEntity);
  }

  /** M√©thode utilitaire pour extraire le contenu d'une entit√© HTTP. */
  private String getEntityContent(HttpEntity entity) throws IOException {
    if (entity instanceof StringEntity) {
      StringEntity stringEntity = (StringEntity) entity;
      return new String(stringEntity.getContent().readAllBytes(), StandardCharsets.UTF_8);
    }
    return "";
  }

  /** Classe de test permettant d'injecter un mock HttpClient. */
  private static class TestableGithubClient extends GithubClient {
    public TestableGithubClient(
        String repository, String authToken, CloseableHttpClient httpClient) {
      super(repository, authToken);
      this.httpClient = httpClient;
    }

    // Cette m√©thode simule l'injection du client HTTP mock√©
    // Dans la vraie impl√©mentation, vous devriez avoir un moyen d'injecter le client
  }

  @Nested
  @DisplayName("Constructeur")
  class ConstructorTest {

    @Test
    @DisplayName("Constructeur avec repository et token valides")
    void testValidConstructor() {
      assertDoesNotThrow(() -> new GithubClient(TEST_REPO, TEST_TOKEN));
    }

    @Test
    @DisplayName("Constructeur avec token null (mode anonyme)")
    void testConstructorWithNullToken() {
      assertDoesNotThrow(() -> new GithubClient(TEST_REPO, null));
    }

    @Test
    @DisplayName("Constructeur avec token vide")
    void testConstructorWithEmptyToken() {
      assertDoesNotThrow(() -> new GithubClient(TEST_REPO, ""));
      assertDoesNotThrow(() -> new GithubClient(TEST_REPO, "   "));
    }

    @ParameterizedTest
    @NullSource
    @EmptySource
    @ValueSource(strings = {"   ", "\t", "\n"})
    @DisplayName("Constructeur rejette repository invalide")
    void testConstructorWithInvalidRepository(String repo) {
      assertThrows(IllegalArgumentException.class, () -> new GithubClient(repo, TEST_TOKEN));
    }

    @Test
    @DisplayName("Constructeur rejette repository sans slash")
    void testConstructorWithMalformedRepository() {
      assertThrows(
          IllegalArgumentException.class,
          () -> new GithubClient("repository-without-slash", TEST_TOKEN));
    }

    @Test
    @DisplayName("Constructeur accepte repository avec slashes multiples")
    void testConstructorWithMultipleSlashes() {
      assertDoesNotThrow(() -> new GithubClient("owner/repo/sub", TEST_TOKEN));
    }
  }

  @Nested
  @DisplayName("fetchPrUnifiedDiff")
  class FetchPrUnifiedDiffTest {

    @BeforeEach
    void setUp() {

      // Configuration par d√©faut des mocks
      // when(mockResponse.getCode()).thenReturn(HttpStatus.SC_OK);
      // when(mockResponse.getEntity()).thenReturn(mockEntity);

      // Cr√©er un nouveau client avec le mock inject√©
      githubClient = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockHttpClient);
      githubClientWithoutToken = new TestableGithubClient(TEST_REPO, null, mockHttpClient);
    }

    @Test
    @DisplayName("R√©cup√©ration r√©ussie du diff")
    void testFetchDiffSuccess() throws IOException, URISyntaxException {
      // Arrange
      when(mockEntity.getContent())
          .thenReturn(new ByteArrayInputStream(TEST_DIFF_CONTENT.getBytes(StandardCharsets.UTF_8)));
      when(mockHttpClient.execute(any(HttpGet.class))).thenReturn(mockResponse);
      when(mockResponse.getEntity()).thenReturn(mockEntity);

      // Act
      String result = githubClient.fetchPrUnifiedDiff(TEST_PR_NUMBER, 3);

      // Assert
      assertEquals(TEST_DIFF_CONTENT, result);

      // V√©rifier que la requ√™te a √©t√© configur√©e correctement
      ArgumentCaptor<HttpGet> requestCaptor = ArgumentCaptor.forClass(HttpGet.class);
      verify(mockHttpClient).execute(requestCaptor.capture());

      HttpGet capturedRequest = requestCaptor.getValue();
      assertTrue(capturedRequest.getUri().toString().contains("/pulls/" + TEST_PR_NUMBER));
      assertEquals(
          "application/vnd.github.v3.diff", capturedRequest.getFirstHeader("Accept").getValue());
      assertEquals(
          "Bearer " + TEST_TOKEN, capturedRequest.getFirstHeader("Authorization").getValue());
    }

    @Test
    @DisplayName("R√©cup√©ration du diff sans token")
    void testFetchDiffWithoutToken() throws IOException {
      // Arrange
      when(mockEntity.getContent())
          .thenReturn(new ByteArrayInputStream(TEST_DIFF_CONTENT.getBytes(StandardCharsets.UTF_8)));
      when(mockHttpClient.execute(any(HttpGet.class))).thenReturn(mockResponse);
      when(mockResponse.getEntity()).thenReturn(mockEntity);

      // Act
      String result = githubClientWithoutToken.fetchPrUnifiedDiff(TEST_PR_NUMBER, 3);

      // Assert
      assertEquals(TEST_DIFF_CONTENT, result);

      // V√©rifier qu'il n'y a pas de header Authorization
      ArgumentCaptor<HttpGet> requestCaptor = ArgumentCaptor.forClass(HttpGet.class);
      verify(mockHttpClient).execute(requestCaptor.capture());

      HttpGet capturedRequest = requestCaptor.getValue();
      assertNull(capturedRequest.getFirstHeader("Authorization"));
    }

    @Test
    @DisplayName("Gestion de l'erreur IOException")
    void testFetchDiffIOException() throws IOException {
      // Arrange
      when(mockHttpClient.execute(any(HttpGet.class))).thenThrow(new IOException("Network error"));

      // Act & Assert
      GithubClient.GithubClientException exception =
          assertThrows(
              GithubClient.GithubClientException.class,
              () -> githubClient.fetchPrUnifiedDiff(TEST_PR_NUMBER, 3));

      assertTrue(exception.getMessage().contains("PR #" + TEST_PR_NUMBER));
      assertNotNull(exception.getCause());
      assertEquals("Network error", exception.getCause().getMessage());
    }

    @ParameterizedTest
    @ValueSource(ints = {0, -1, -100})
    @DisplayName("Validation du num√©ro de PR invalide")
    void testFetchDiffInvalidPrNumber(int prNumber) {
      assertThrows(
          IllegalArgumentException.class, () -> githubClient.fetchPrUnifiedDiff(prNumber, 3));
    }

    @Test
    @DisplayName("Diff vide retourn√© correctement")
    void testFetchEmptyDiff() throws IOException {
      // Arrange
      when(mockEntity.getContent())
          .thenReturn(new ByteArrayInputStream("".getBytes(StandardCharsets.UTF_8)));
      when(mockHttpClient.execute(any(HttpGet.class))).thenReturn(mockResponse);
      when(mockResponse.getEntity()).thenReturn(mockEntity);

      // Act
      String result = githubClient.fetchPrUnifiedDiff(TEST_PR_NUMBER, 3);

      // Assert
      assertEquals("", result);
    }
  }

  @Nested
  @DisplayName("postIssueComment")
  class PostIssueCommentTest {

    @BeforeEach
    void setUp() {
      githubClient = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockHttpClient);
      githubClientWithoutToken = new TestableGithubClient(TEST_REPO, null, mockHttpClient);
    }

    @Test
    @DisplayName("Publication r√©ussie d'un commentaire")
    void testPostCommentSuccess() throws IOException, URISyntaxException {
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_OK);
      when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockResponse);
      // Act
      assertDoesNotThrow(() -> githubClient.postIssueComment(TEST_PR_NUMBER, TEST_COMMENT));

      // Assert
      ArgumentCaptor<HttpPost> requestCaptor = ArgumentCaptor.forClass(HttpPost.class);
      verify(mockHttpClient).execute(requestCaptor.capture());

      HttpPost capturedRequest = requestCaptor.getValue();
      assertTrue(
          capturedRequest.getUri().toString().contains("/issues/" + TEST_PR_NUMBER + "/comments"));
      assertEquals(
          "application/vnd.github+json", capturedRequest.getFirstHeader("Accept").getValue());
      assertEquals(
          "Bearer " + TEST_TOKEN, capturedRequest.getFirstHeader("Authorization").getValue());

      // V√©rifier le contenu JSON
      String jsonContent = getEntityContent(capturedRequest.getEntity());
      assertTrue(jsonContent.contains("\"body\":\"" + TEST_COMMENT + "\""));
    }

    @Test
    @DisplayName("Publication d'un commentaire avec caract√®res sp√©ciaux")
    void testPostCommentWithSpecialCharacters() throws IOException {
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_OK);
      when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockResponse);
      // Arrange
      String specialComment = "Comment with \"quotes\" and \nnewlines and √©mojis üéâ";

      // Act
      assertDoesNotThrow(() -> githubClient.postIssueComment(TEST_PR_NUMBER, specialComment));

      // Assert
      ArgumentCaptor<HttpPost> requestCaptor = ArgumentCaptor.forClass(HttpPost.class);
      verify(mockHttpClient).execute(requestCaptor.capture());

      String jsonContent = getEntityContent(requestCaptor.getValue().getEntity());
      assertTrue(jsonContent.contains("Comment with \\\"quotes\\\""));
    }

    @Test
    @DisplayName("Publication d'un commentaire Markdown")
    void testPostCommentWithMarkdown() throws IOException {
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_OK);
      when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockResponse);
      // Arrange
      String markdownComment = "# Title\n\n**Bold** and *italic*\n\n```java\ncode block\n```";

      // Act & Assert
      assertDoesNotThrow(() -> githubClient.postIssueComment(TEST_PR_NUMBER, markdownComment));
    }

    @Test
    @DisplayName("Gestion de l'erreur HTTP")
    void testPostCommentHttpError() throws IOException {
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_OK);
      when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockResponse);
      // Arrange
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_FORBIDDEN);

      // Act & Assert
      GithubClient.GithubClientException exception =
          assertThrows(
              GithubClient.GithubClientException.class,
              () -> githubClient.postIssueComment(TEST_PR_NUMBER, TEST_COMMENT));

      assertTrue(exception.getMessage().contains("403"));
    }

    @ParameterizedTest
    @NullSource
    @EmptySource
    @ValueSource(strings = {"   ", "\t", "\n"})
    @DisplayName("Validation du corps de commentaire invalide")
    void testPostCommentInvalidBody(String body) {
      assertThrows(
          IllegalArgumentException.class,
          () -> githubClient.postIssueComment(TEST_PR_NUMBER, body));
    }

    @ParameterizedTest
    @ValueSource(ints = {0, -1, -999})
    @DisplayName("Validation du num√©ro d'issue invalide")
    void testPostCommentInvalidIssueNumber(int issueNumber) {
      assertThrows(
          IllegalArgumentException.class,
          () -> githubClient.postIssueComment(issueNumber, TEST_COMMENT));
    }
  }

  @Nested
  @DisplayName("createReview")
  @Disabled
  class CreateReviewTest {

    private List<GithubClient.ReviewComment> validComments;

    @BeforeEach
    void setUp() throws IOException {
      githubClient = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockHttpClient);
      validComments =
          Arrays.asList(
              new GithubClient.ReviewComment("src/Main.java", 10, "First comment"),
              new GithubClient.ReviewComment("src/Test.java", 20, "Second comment"));
    }

    @Test
    @DisplayName("Cr√©ation r√©ussie d'une review avec commentaires")
    void testCreateReviewSuccess() throws IOException, URISyntaxException {
      when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockResponse);
      // Act
      assertDoesNotThrow(() -> githubClient.createReview(TEST_PR_NUMBER, validComments));

      // Assert
      ArgumentCaptor<HttpPost> requestCaptor = ArgumentCaptor.forClass(HttpPost.class);
      verify(mockHttpClient).execute(requestCaptor.capture());

      HttpPost capturedRequest = requestCaptor.getValue();
      assertTrue(
          capturedRequest.getUri().toString().contains("/pulls/" + TEST_PR_NUMBER + "/reviews"));

      String jsonContent = getEntityContent(capturedRequest.getEntity());
      assertTrue(jsonContent.contains("\"event\":\"COMMENT\""));
      assertTrue(jsonContent.contains("\"path\":\"src/Main.java\""));
      assertTrue(jsonContent.contains("\"position\":10"));
      assertTrue(jsonContent.contains("\"body\":\"First comment\""));
      assertTrue(jsonContent.contains("\"path\":\"src/Test.java\""));
      assertTrue(jsonContent.contains("\"position\":20"));
      assertTrue(jsonContent.contains("\"body\":\"Second comment\""));
    }

    @Test
    @DisplayName("Cr√©ation d'une review avec un seul commentaire")
    void testCreateReviewSingleComment() {
      // Arrange
      List<GithubClient.ReviewComment> singleComment =
          Collections.singletonList(
              new GithubClient.ReviewComment("file.txt", 1, "Single comment"));

      // Act & Assert
      assertDoesNotThrow(() -> githubClient.createReview(TEST_PR_NUMBER, singleComment));
    }

    @Test
    @DisplayName("Validation de la liste de commentaires null")
    void testCreateReviewNullComments() {
      assertThrows(
          IllegalArgumentException.class, () -> githubClient.createReview(TEST_PR_NUMBER, null));
    }

    @Test
    @DisplayName("Validation de la liste de commentaires vide")
    void testCreateReviewEmptyComments() {
      assertThrows(
          IllegalArgumentException.class,
          () -> githubClient.createReview(TEST_PR_NUMBER, Collections.emptyList()));
    }

    @Test
    @DisplayName("Validation d'un commentaire null dans la liste")
    void testCreateReviewWithNullComment() {
      List<GithubClient.ReviewComment> commentsWithNull =
          Arrays.asList(new GithubClient.ReviewComment("file.txt", 1, "Valid comment"), null);

      assertThrows(
          IllegalArgumentException.class,
          () -> githubClient.createReview(TEST_PR_NUMBER, commentsWithNull));
    }

    @Test
    @DisplayName("Gestion de l'erreur HTTP lors de la cr√©ation de review")
    void testCreateReviewHttpError() {
      // Arrange
      when(mockResponse.getCode()).thenReturn(HttpStatus.SC_UNPROCESSABLE_ENTITY);

      // Act & Assert
      GithubClient.GithubClientException exception =
          assertThrows(
              GithubClient.GithubClientException.class,
              () -> githubClient.createReview(TEST_PR_NUMBER, validComments));

      assertTrue(exception.getMessage().contains("422"));
    }

    @ParameterizedTest
    @ValueSource(ints = {0, -1, -100})
    @DisplayName("Validation du num√©ro de PR invalide")
    void testCreateReviewInvalidPrNumber(int prNumber) {
      assertThrows(
          IllegalArgumentException.class, () -> githubClient.createReview(prNumber, validComments));
    }
  }

  @Nested
  @DisplayName("ReviewComment")
  @Disabled
  class ReviewCommentTest {

    @Test
    @DisplayName("Cr√©ation d'un ReviewComment valide")
    void testValidReviewComment() {
      assertDoesNotThrow(
          () -> new GithubClient.ReviewComment("path/to/file.java", 42, "Comment body"));
    }

    @Test
    @DisplayName("ReviewComment avec position z√©ro")
    void testReviewCommentWithZeroPosition() {
      assertDoesNotThrow(
          () -> new GithubClient.ReviewComment("file.txt", 0, "Comment at position 0"));
    }

    @Test
    @DisplayName("ReviewComment rejette un path null")
    void testReviewCommentNullPath() {
      assertThrows(
          NullPointerException.class, () -> new GithubClient.ReviewComment(null, 10, "Body"));
    }

    @Test
    @DisplayName("ReviewComment rejette un path vide")
    void testReviewCommentEmptyPath() {
      assertThrows(
          IllegalArgumentException.class, () -> new GithubClient.ReviewComment("", 10, "Body"));
      assertThrows(
          IllegalArgumentException.class, () -> new GithubClient.ReviewComment("   ", 10, "Body"));
    }

    @Test
    @DisplayName("ReviewComment rejette un body null")
    void testReviewCommentNullBody() {
      assertThrows(
          NullPointerException.class, () -> new GithubClient.ReviewComment("file.txt", 10, null));
    }

    @Test
    @DisplayName("ReviewComment rejette un body vide")
    void testReviewCommentEmptyBody() {
      assertThrows(
          IllegalArgumentException.class, () -> new GithubClient.ReviewComment("file.txt", 10, ""));
      assertThrows(
          IllegalArgumentException.class,
          () -> new GithubClient.ReviewComment("file.txt", 10, "   "));
    }

    @Test
    @DisplayName("ReviewComment rejette une position n√©gative")
    void testReviewCommentNegativePosition() {
      assertThrows(
          IllegalArgumentException.class,
          () -> new GithubClient.ReviewComment("file.txt", -1, "Body"));
    }

    @Test
    @DisplayName("Accesseurs du record ReviewComment")
    void testReviewCommentAccessors() {
      GithubClient.ReviewComment comment =
          new GithubClient.ReviewComment("path/file.txt", 25, "Test body");

      assertEquals("path/file.txt", comment.path());
      assertEquals(25, comment.position());
      assertEquals("Test body", comment.body());
    }
  }

  @Nested
  @DisplayName("GithubClientException")
  class GithubClientExceptionTest {

    @Test
    @DisplayName("Exception avec message seulement")
    void testExceptionWithMessage() {
      GithubClient.GithubClientException exception =
          new GithubClient.GithubClientException("Error message");

      assertEquals("Error message", exception.getMessage());
      assertNull(exception.getCause());
    }

    @Test
    @DisplayName("Exception avec message et cause")
    void testExceptionWithMessageAndCause() {
      IOException cause = new IOException("IO error");
      GithubClient.GithubClientException exception =
          new GithubClient.GithubClientException("Wrapped error", cause);

      assertEquals("Wrapped error", exception.getMessage());
      assertEquals(cause, exception.getCause());
    }
  }

  @Nested
  @DisplayName("Int√©gration et cas limites")
  @Disabled
  class IntegrationAndEdgeCasesTest {

    @BeforeEach
    void setUp() {
      githubClient = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockHttpClient);
    }

    @Test
    @DisplayName("Chemins de fichiers avec caract√®res sp√©ciaux")
    void testReviewCommentWithSpecialCharacters() {
      List<GithubClient.ReviewComment> comments =
          Arrays.asList(
              new GithubClient.ReviewComment("src/caf√©/√©t√©.java", 10, "Comment with √©mojis üéâ"),
              new GithubClient.ReviewComment("path with spaces/file.txt", 20, "Another comment"));

      assertDoesNotThrow(() -> githubClient.createReview(TEST_PR_NUMBER, comments));
    }

    @Test
    @DisplayName("Tr√®s long commentaire")
    void testVeryLongComment() {
      String longComment = "A".repeat(10000); // 10,000 caract√®res

      assertDoesNotThrow(() -> githubClient.postIssueComment(TEST_PR_NUMBER, longComment));
    }

    @Test
    @DisplayName("Beaucoup de commentaires dans une review")
    void testManyReviewComments() {
      List<GithubClient.ReviewComment> manyComments = new ArrayList<>();
      for (int i = 0; i < 100; i++) {
        manyComments.add(new GithubClient.ReviewComment("file" + i + ".txt", i, "Comment " + i));
      }

      assertDoesNotThrow(() -> githubClient.createReview(TEST_PR_NUMBER, manyComments));
    }

    @Test
    @DisplayName("Repository avec structure complexe")
    void testComplexRepositoryStructure() {
      // Repository avec sous-modules ou structure inhabituelle
      GithubClient complexClient =
          new TestableGithubClient("org/project/submodule", TEST_TOKEN, mockHttpClient);

      assertNotNull(complexClient);
    }
  }

  @Nested
  @DisplayName("Gestion des ressources")
  @Disabled
  class ResourceManagementTest {

    @Test
    @DisplayName("Fermeture du client")
    void testCloseClient() throws IOException {
      CloseableHttpClient mockClient = mock(CloseableHttpClient.class);
      GithubClient client = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockClient);

      // Act
      client.close();

      // Assert
      verify(mockClient).close();
    }

    @Test
    @DisplayName("Fermeture multiple du client")
    void testMultipleClose() {
      CloseableHttpClient mockClient = mock(CloseableHttpClient.class);
      GithubClient client = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockClient);

      // Act & Assert - ne devrait pas lancer d'exception
      assertDoesNotThrow(
          () -> {
            client.close();
            client.close();
          });
    }
  }

  @Nested
  @DisplayName("Codes de statut HTTP")
  @Disabled
  class HttpStatusCodesTest {

    @BeforeEach
    void setUp() throws IOException {
      githubClient = new TestableGithubClient(TEST_REPO, TEST_TOKEN, mockHttpClient);
      when(mockHttpClient.execute(any())).thenReturn(mockResponse);
    }

    @ParameterizedTest
    @CsvSource({
      "200, false", // OK
      "201, false", // Created
      "204, false", // No Content
      "299, false", // Derni√®re valeur 2xx valide
      "300, true", // Multiple Choices - erreur
      "400, true", // Bad Request
      "401, true", // Unauthorized
      "403, true", // Forbidden
      "404, true", // Not Found
      "422, true", // Unprocessable Entity
      "500, true", // Internal Server Error
      "503, true" // Service Unavailable
    })
    @DisplayName("Gestion des diff√©rents codes de statut HTTP")
    void testHttpStatusCodes(int statusCode, boolean shouldThrow) {
      // Arrange
      when(mockResponse.getCode()).thenReturn(statusCode);

      // Act & Assert
      if (shouldThrow) {
        assertThrows(
            GithubClient.GithubClientException.class,
            () -> githubClient.postIssueComment(TEST_PR_NUMBER, TEST_COMMENT));
      } else {
        assertDoesNotThrow(() -> githubClient.postIssueComment(TEST_PR_NUMBER, TEST_COMMENT));
      }
    }
  }
}
